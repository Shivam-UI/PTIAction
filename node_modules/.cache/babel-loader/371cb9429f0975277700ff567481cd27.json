{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar PUNCTUATION_LIST = [\".\", \",\", \"!\", \"?\", \"'\", \"{\", \"}\", \"(\", \")\", \"[\", \"]\", \"/\"];\n\nvar trimText = function trimText(text) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 80;\n  var ideal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n  var max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 200; //This main function uses two pointers to move out from the ideal, to find the first instance of a punctuation mark followed by a space. If one cannot be found, it will go with the first space closest to the ideal.\n\n  if (max < min || ideal > max || ideal < min) {\n    throw new Error(\"The minimum length must be less than the maximum, and the ideal must be between the minimum and maximum.\");\n  }\n\n  if (text.length < ideal) {\n    return [text, ''];\n  }\n\n  var pointerOne = ideal;\n  var pointerTwo = ideal;\n  var firstSpace, resultIdx;\n\n  var setSpace = function setSpace(idx) {\n    if (spaceMatch(text[idx])) {\n      firstSpace = firstSpace || idx;\n    }\n  };\n\n  while (pointerOne < max || pointerTwo > min) {\n    if (checkMatch(pointerOne, text, max, min)) {\n      resultIdx = pointerOne + 1;\n      break;\n    } else if (checkMatch(pointerTwo, text, max, min)) {\n      resultIdx = pointerTwo + 1;\n      break;\n    } else {\n      setSpace(pointerOne);\n      setSpace(pointerTwo);\n    }\n\n    pointerOne++;\n    pointerTwo--;\n  }\n\n  if (resultIdx === undefined) {\n    if (firstSpace && firstSpace >= min && firstSpace <= max) {\n      resultIdx = firstSpace;\n    } else if (ideal - min < max - ideal) {\n      resultIdx = min;\n    } else {\n      resultIdx = max;\n    }\n  }\n\n  return [text.slice(0, resultIdx), text.slice(resultIdx).trim()];\n};\n\nvar spaceMatch = function spaceMatch(character) {\n  if (character === \" \") {\n    return true;\n  }\n};\n\nvar punctuationMatch = function punctuationMatch(idx, text) {\n  var punctuationIdx = PUNCTUATION_LIST.indexOf(text[idx]);\n\n  if (punctuationIdx >= 0 && spaceMatch(text[idx + 1])) {\n    return true;\n  }\n};\n\nvar checkMatch = function checkMatch(idx, text, max, min) {\n  if (idx < max && idx > min && punctuationMatch(idx, text)) {\n    return true;\n  }\n};\n\nvar _default = trimText;\nexports[\"default\"] = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","PUNCTUATION_LIST","trimText","text","min","arguments","length","undefined","ideal","max","Error","pointerOne","pointerTwo","firstSpace","resultIdx","setSpace","idx","spaceMatch","checkMatch","slice","trim","character","punctuationMatch","punctuationIdx","indexOf","_default"],"sources":["/Users/sofe/Documents/CodeBackup/PtiWebApps/node_modules/read-more-react/dist/utils/trimText.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar PUNCTUATION_LIST = [\".\", \",\", \"!\", \"?\", \"'\", \"{\", \"}\", \"(\", \")\", \"[\", \"]\", \"/\"];\n\nvar trimText = function trimText(text) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 80;\n  var ideal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n  var max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 200;\n\n  //This main function uses two pointers to move out from the ideal, to find the first instance of a punctuation mark followed by a space. If one cannot be found, it will go with the first space closest to the ideal.\n  if (max < min || ideal > max || ideal < min) {\n    throw new Error(\"The minimum length must be less than the maximum, and the ideal must be between the minimum and maximum.\");\n  }\n\n  if (text.length < ideal) {\n    return [text, ''];\n  }\n\n  var pointerOne = ideal;\n  var pointerTwo = ideal;\n  var firstSpace, resultIdx;\n\n  var setSpace = function setSpace(idx) {\n    if (spaceMatch(text[idx])) {\n      firstSpace = firstSpace || idx;\n    }\n  };\n\n  while (pointerOne < max || pointerTwo > min) {\n    if (checkMatch(pointerOne, text, max, min)) {\n      resultIdx = pointerOne + 1;\n      break;\n    } else if (checkMatch(pointerTwo, text, max, min)) {\n      resultIdx = pointerTwo + 1;\n      break;\n    } else {\n      setSpace(pointerOne);\n      setSpace(pointerTwo);\n    }\n\n    pointerOne++;\n    pointerTwo--;\n  }\n\n  if (resultIdx === undefined) {\n    if (firstSpace && firstSpace >= min && firstSpace <= max) {\n      resultIdx = firstSpace;\n    } else if (ideal - min < max - ideal) {\n      resultIdx = min;\n    } else {\n      resultIdx = max;\n    }\n  }\n\n  return [text.slice(0, resultIdx), text.slice(resultIdx).trim()];\n};\n\nvar spaceMatch = function spaceMatch(character) {\n  if (character === \" \") {\n    return true;\n  }\n};\n\nvar punctuationMatch = function punctuationMatch(idx, text) {\n  var punctuationIdx = PUNCTUATION_LIST.indexOf(text[idx]);\n\n  if (punctuationIdx >= 0 && spaceMatch(text[idx + 1])) {\n    return true;\n  }\n};\n\nvar checkMatch = function checkMatch(idx, text, max, min) {\n  if (idx < max && idx > min && punctuationMatch(idx, text)) {\n    return true;\n  }\n};\n\nvar _default = trimText;\nexports[\"default\"] = _default;"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAAC,SAAD,CAAP,GAAqB,KAAK,CAA1B;AACA,IAAIE,gBAAgB,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8C,GAA9C,EAAmD,GAAnD,EAAwD,GAAxD,CAAvB;;AAEA,IAAIC,QAAQ,GAAG,SAASA,QAAT,CAAkBC,IAAlB,EAAwB;EACrC,IAAIC,GAAG,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA9E;EACA,IAAIG,KAAK,GAAGH,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,GAAhF;EACA,IAAII,GAAG,GAAGJ,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,GAA9E,CAHqC,CAKrC;;EACA,IAAII,GAAG,GAAGL,GAAN,IAAaI,KAAK,GAAGC,GAArB,IAA4BD,KAAK,GAAGJ,GAAxC,EAA6C;IAC3C,MAAM,IAAIM,KAAJ,CAAU,0GAAV,CAAN;EACD;;EAED,IAAIP,IAAI,CAACG,MAAL,GAAcE,KAAlB,EAAyB;IACvB,OAAO,CAACL,IAAD,EAAO,EAAP,CAAP;EACD;;EAED,IAAIQ,UAAU,GAAGH,KAAjB;EACA,IAAII,UAAU,GAAGJ,KAAjB;EACA,IAAIK,UAAJ,EAAgBC,SAAhB;;EAEA,IAAIC,QAAQ,GAAG,SAASA,QAAT,CAAkBC,GAAlB,EAAuB;IACpC,IAAIC,UAAU,CAACd,IAAI,CAACa,GAAD,CAAL,CAAd,EAA2B;MACzBH,UAAU,GAAGA,UAAU,IAAIG,GAA3B;IACD;EACF,CAJD;;EAMA,OAAOL,UAAU,GAAGF,GAAb,IAAoBG,UAAU,GAAGR,GAAxC,EAA6C;IAC3C,IAAIc,UAAU,CAACP,UAAD,EAAaR,IAAb,EAAmBM,GAAnB,EAAwBL,GAAxB,CAAd,EAA4C;MAC1CU,SAAS,GAAGH,UAAU,GAAG,CAAzB;MACA;IACD,CAHD,MAGO,IAAIO,UAAU,CAACN,UAAD,EAAaT,IAAb,EAAmBM,GAAnB,EAAwBL,GAAxB,CAAd,EAA4C;MACjDU,SAAS,GAAGF,UAAU,GAAG,CAAzB;MACA;IACD,CAHM,MAGA;MACLG,QAAQ,CAACJ,UAAD,CAAR;MACAI,QAAQ,CAACH,UAAD,CAAR;IACD;;IAEDD,UAAU;IACVC,UAAU;EACX;;EAED,IAAIE,SAAS,KAAKP,SAAlB,EAA6B;IAC3B,IAAIM,UAAU,IAAIA,UAAU,IAAIT,GAA5B,IAAmCS,UAAU,IAAIJ,GAArD,EAA0D;MACxDK,SAAS,GAAGD,UAAZ;IACD,CAFD,MAEO,IAAIL,KAAK,GAAGJ,GAAR,GAAcK,GAAG,GAAGD,KAAxB,EAA+B;MACpCM,SAAS,GAAGV,GAAZ;IACD,CAFM,MAEA;MACLU,SAAS,GAAGL,GAAZ;IACD;EACF;;EAED,OAAO,CAACN,IAAI,CAACgB,KAAL,CAAW,CAAX,EAAcL,SAAd,CAAD,EAA2BX,IAAI,CAACgB,KAAL,CAAWL,SAAX,EAAsBM,IAAtB,EAA3B,CAAP;AACD,CAnDD;;AAqDA,IAAIH,UAAU,GAAG,SAASA,UAAT,CAAoBI,SAApB,EAA+B;EAC9C,IAAIA,SAAS,KAAK,GAAlB,EAAuB;IACrB,OAAO,IAAP;EACD;AACF,CAJD;;AAMA,IAAIC,gBAAgB,GAAG,SAASA,gBAAT,CAA0BN,GAA1B,EAA+Bb,IAA/B,EAAqC;EAC1D,IAAIoB,cAAc,GAAGtB,gBAAgB,CAACuB,OAAjB,CAAyBrB,IAAI,CAACa,GAAD,CAA7B,CAArB;;EAEA,IAAIO,cAAc,IAAI,CAAlB,IAAuBN,UAAU,CAACd,IAAI,CAACa,GAAG,GAAG,CAAP,CAAL,CAArC,EAAsD;IACpD,OAAO,IAAP;EACD;AACF,CAND;;AAQA,IAAIE,UAAU,GAAG,SAASA,UAAT,CAAoBF,GAApB,EAAyBb,IAAzB,EAA+BM,GAA/B,EAAoCL,GAApC,EAAyC;EACxD,IAAIY,GAAG,GAAGP,GAAN,IAAaO,GAAG,GAAGZ,GAAnB,IAA0BkB,gBAAgB,CAACN,GAAD,EAAMb,IAAN,CAA9C,EAA2D;IACzD,OAAO,IAAP;EACD;AACF,CAJD;;AAMA,IAAIsB,QAAQ,GAAGvB,QAAf;AACAH,OAAO,CAAC,SAAD,CAAP,GAAqB0B,QAArB"},"metadata":{},"sourceType":"script"}